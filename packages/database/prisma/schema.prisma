datasource db {
    provider  = "postgresql"
    url       = env("POSTGRES_PRISMA_URL")
    directUrl = env("POSTGRES_URL_NON_POOLING")
    schemas   = ["public", "pgboss"]
}

generator client {
    provider        = "prisma-client-js"
    output          = "./generated/client"
    binaryTargets   = ["native", "darwin-arm64"]
    previewFeatures = ["multiSchema"]
}

generator zod {
    provider = "prisma-zod-generator"
    output   = "./zod"
    config   = "./zod-generator.config.json"
}

model User {
    id                 String       @id @default(cuid())
    name               String
    email              String
    emailVerified      Boolean
    image              String?
    createdAt          DateTime
    updatedAt          DateTime
    username           String?
    role               String?
    banned             Boolean?
    banReason          String?
    banExpires         DateTime?
    onboardingComplete Boolean      @default(false)
    paymentsCustomerId String?
    locale             String?
    twoFactorEnabled   Boolean?
    sessions           Session[]
    accounts           Account[]
    passkeys           Passkey[]
    invitations        Invitation[]
    purchases          Purchase[]
    members            Member[]
    twofactors         TwoFactor[]
    aiChats            AiChat[]
    toolJobs           ToolJob[]

    @@unique([email])
    @@unique([username])
    @@map("user")
    @@schema("public")
}

model Session {
    id        String   @id @default(cuid())
    expiresAt DateTime
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    impersonatedBy String?

    activeOrganizationId String?

    token     String
    createdAt DateTime
    updatedAt DateTime

    @@unique([token])
    @@map("session")
    @@schema("public")
}

model Account {
    id           String    @id @default(cuid())
    accountId    String
    providerId   String
    userId       String
    user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken  String?   @db.Text
    refreshToken String?   @db.Text
    idToken      String?   @db.Text
    expiresAt    DateTime?
    password     String?

    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    createdAt             DateTime
    updatedAt             DateTime

    @@map("account")
    @@schema("public")
}

model Verification {
    id         String   @id @default(cuid())
    identifier String
    value      String   @db.Text
    expiresAt  DateTime

    createdAt DateTime?
    updatedAt DateTime?

    @@map("verification")
    @@schema("public")
}

model Passkey {
    id           String    @id @default(cuid())
    name         String?
    publicKey    String
    userId       String
    user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    credentialID String
    counter      Int
    deviceType   String
    backedUp     Boolean
    transports   String?
    createdAt    DateTime?

    @@map("passkey")
    @@schema("public")
}

model TwoFactor {
    id          String @id @default(cuid())
    secret      String
    backupCodes String
    userId      String
    user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("twoFactor")
    @@schema("public")
}

model Organization {
    id                 String       @id @default(cuid())
    name               String
    slug               String?
    logo               String?
    createdAt          DateTime
    metadata           String?
    paymentsCustomerId String?
    members            Member[]
    invitations        Invitation[]
    purchases          Purchase[]
    aiChats            AiChat[]

    @@unique([slug])
    @@map("organization")
    @@schema("public")
}

model Member {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
    role           String
    createdAt      DateTime

    @@unique([organizationId, userId])
    @@map("member")
    @@schema("public")
}

model Invitation {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    email          String
    role           String?
    status         String
    expiresAt      DateTime
    inviterId      String
    user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

    @@map("invitation")
    @@schema("public")
}

enum PurchaseType {
    SUBSCRIPTION
    ONE_TIME

    @@schema("public")
}

model Purchase {
    id             String        @id @default(cuid())
    organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    organizationId String?
    user           User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId         String?
    type           PurchaseType
    customerId     String
    subscriptionId String?       @unique
    productId      String
    status         String?
    createdAt      DateTime      @default(now())
    updatedAt      DateTime      @updatedAt

    @@index([subscriptionId])
    @@map("purchase")
    @@schema("public")
}

model AiChat {
    id             String        @id @default(cuid())
    organizationId String?
    organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId         String?
    user           User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
    title          String?
    /// [ChatMessages]
    messages       Json          @default("[]")
    createdAt      DateTime      @default(now())
    updatedAt      DateTime      @updatedAt

    @@map("ai_chat")
    @@schema("public")
}

enum ToolJobStatus {
    PENDING
    PROCESSING
    COMPLETED
    FAILED
    CANCELLED

    @@schema("public")
}

model ToolJob {
    id          String        @id @default(cuid())
    toolSlug    String
    status      ToolJobStatus @default(PENDING)
    priority    Int           @default(0)

    // Input/Output
    input       Json          // Tool-specific input data
    output      Json?         // Tool-specific output data
    error       String?       // Error message if failed

    // Ownership
    userId      String?
    user        User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
    sessionId   String?       // For anonymous users

    // pg-boss integration
    pgBossJobId String?       @unique // Links to pg-boss job ID (UUID)

    // Tracking
    attempts    Int           @default(0)
    maxAttempts Int           @default(3)
    startedAt   DateTime?
    completedAt DateTime?
    expiresAt   DateTime      // Cleanup after this time

    createdAt   DateTime      @default(now())
    updatedAt   DateTime      @updatedAt

    @@index([status, priority])
    @@index([toolSlug, status])
    @@index([userId])
    @@index([sessionId])
    @@index([expiresAt])
    @@map("tool_job")
    @@schema("public")
}

model RateLimitEntry {
    id          String   @id @default(cuid())
    identifier  String   // 'anon:sessionId:ip' or 'user:userId' or 'org:orgId'
    toolSlug    String
    windowStart DateTime
    windowEnd   DateTime
    count       Int      @default(0)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@unique([identifier, toolSlug, windowStart])
    @@index([identifier, toolSlug])
    @@index([windowEnd])
    @@map("rate_limit_entry")
    @@schema("public")
}

// Audit logging for compliance and security tracking
enum AuditAction {
    CREATE
    READ
    UPDATE
    DELETE
    LOGIN
    LOGOUT
    PASSWORD_CHANGE
    MFA_SETUP
    MFA_DISABLE
    IMPERSONATE
    INVITE
    EXPORT
    SUBSCRIPTION_CHANGE
    PAYMENT

    @@schema("public")
}

model AuditLog {
    id             String      @id @default(cuid())
    createdAt      DateTime    @default(now())

    // Actor information
    userId         String?     // Nullable for anonymous/system actions
    organizationId String?     // Nullable for personal actions

    // Action details
    action         AuditAction
    resource       String      // e.g., "user", "organization", "subscription", "member"
    resourceId     String?     // ID of the affected resource

    // Request context
    ipAddress      String?
    userAgent      String?
    sessionId      String?     // Reference to session for traceability

    // Result and metadata
    success        Boolean     @default(true)
    metadata       Json?       // Additional context (e.g., changed fields, error details)

    // Retention management
    expiresAt      DateTime?   // For retention policy cleanup

    @@index([userId])
    @@index([organizationId])
    @@index([action])
    @@index([resource])
    @@index([createdAt])
    @@index([expiresAt])
    @@index([userId, createdAt])
    @@index([organizationId, createdAt])
    @@map("audit_log")
    @@schema("public")
}
